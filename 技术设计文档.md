# 知识库管理系统技术设计文档

## 1. 系统架构概述

### 1.1 技术栈
- **Java后端**: Spring Boot + Spring Security + MyBatis Plus + Elasticsearch Client + MySQL
- **Python服务**: FastAPI + PyMuPDF4LLM + Sentence Transformers + Elasticsearch + 本地部署LLM
- **前端**: Vue.js/React + WebSocket/SSE
- **服务通信**: HTTP REST API (Java-Python)

### 1.2 系统分工
- **Java**: 业务逻辑、用户交互、数据管理、权限控制
- **Python**: LLM+RAG核心功能、文档处理、向量检索

## 2. 数据库设计

### 2.0 数据库配置
- **数据库**: MySQL 8.0+
- **ORM框架**: MyBatis Plus
- **连接池**: HikariCP
- **设计原则**: 单表设计，不使用外键约束，在应用层保证数据一致性
- **类目设计**: 使用自增ID作为主键，不使用编码字段，简化设计

#### 2.0.1 MyBatis Plus依赖配置
```xml
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.5.3</version>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.33</version>
</dependency>
```

#### 2.0.2 应用配置
```yaml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/knowledge_base?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai
    username: root
    password: password
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000

mybatis-plus:
  configuration:
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      logic-delete-field: deleted
      logic-delete-value: 1
      logic-not-delete-value: 0

# JWT配置
jwt:
  secret: your-secret-key-here-must-be-very-long-and-secure
  expiration: 604800  # 7天，单位：秒
```

### 2.1 用户表 (users)
```sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    role VARCHAR(20) NOT NULL,
    status TINYINT DEFAULT 1,
    created_time DATETIME NOT NULL,
    updated_time DATETIME,
    deleted TINYINT DEFAULT 0 COMMENT '逻辑删除标识'
);
```

### 2.2 三级类目表 (categories)
```sql
CREATE TABLE categories (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL COMMENT '类目名称',
    level INT NOT NULL COMMENT '层级：1-一级类目，2-二级类目，3-三级类目',
    parent_id BIGINT COMMENT '父类目ID',
    sort_order INT DEFAULT 0 COMMENT '排序',
    status TINYINT DEFAULT 1 COMMENT '状态：1-启用，0-禁用',
    description TEXT COMMENT '类目描述',
    created_by VARCHAR(50) NOT NULL COMMENT '创建人',
    created_time DATETIME NOT NULL COMMENT '创建时间',
    updated_by VARCHAR(50) COMMENT '更新人',
    updated_time DATETIME COMMENT '更新时间'
);
```

### 2.3 类目变更历史表 (category_change_logs)
```sql
CREATE TABLE category_change_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    category_id BIGINT NOT NULL COMMENT '类目ID',
    change_type VARCHAR(20) NOT NULL COMMENT '变更类型：CREATE/UPDATE/DELETE',
    old_data JSON COMMENT '变更前数据',
    new_data JSON COMMENT '变更后数据',
    change_reason VARCHAR(500) COMMENT '变更原因',
    changed_by VARCHAR(50) NOT NULL COMMENT '变更人',
    changed_time DATETIME NOT NULL COMMENT '变更时间'
);
```

### 2.4 知识表 (knowledge)
```sql
CREATE TABLE knowledge (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(200) NOT NULL COMMENT '知识名称',
    description TEXT COMMENT '文字描述',
    category_id BIGINT NOT NULL COMMENT '三级类目ID',
    tags JSON COMMENT '标签列表',
    effective_start_time DATETIME COMMENT '生效开始时间',
    effective_end_time DATETIME COMMENT '生效结束时间',
    status TINYINT DEFAULT 1 COMMENT '状态：1-生效，0-失效',
    created_by VARCHAR(50) NOT NULL COMMENT '创建人',
    created_time DATETIME NOT NULL COMMENT '创建时间',
    updated_by VARCHAR(50) COMMENT '更新人',
    updated_time DATETIME COMMENT '更新时间',
    search_count INT DEFAULT 0 COMMENT '搜索次数',
    download_count INT DEFAULT 0 COMMENT '下载次数'
);
```

### 2.5 知识版本表 (knowledge_versions)
```sql
CREATE TABLE knowledge_versions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    knowledge_id BIGINT NOT NULL COMMENT '知识ID',
    version_number INT NOT NULL COMMENT '版本号',
    name VARCHAR(200) NOT NULL COMMENT '知识名称',
    description TEXT COMMENT '文字描述',
    category_id BIGINT NOT NULL COMMENT '三级类目ID',
    tags JSON COMMENT '标签列表',
    effective_start_time DATETIME COMMENT '生效开始时间',
    effective_end_time DATETIME COMMENT '生效结束时间',
    created_by VARCHAR(50) NOT NULL COMMENT '创建人',
    created_time DATETIME NOT NULL COMMENT '创建时间',
    change_reason VARCHAR(500) COMMENT '变更原因'
);
```

### 2.6 附件表 (attachments)
```sql
CREATE TABLE attachments (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    knowledge_id BIGINT NOT NULL COMMENT '知识ID',
    file_name VARCHAR(200) NOT NULL COMMENT '文件名',
    file_path VARCHAR(500) NOT NULL COMMENT '文件路径',
    file_size BIGINT NOT NULL COMMENT '文件大小(字节)',
    file_type VARCHAR(50) COMMENT '文件类型',
    upload_time DATETIME NOT NULL COMMENT '上传时间',
    download_count INT DEFAULT 0 COMMENT '下载次数'
);
```

### 2.7 用户交互表 (user_interactions)
```sql
CREATE TABLE user_interactions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL COMMENT '用户ID',
    knowledge_id BIGINT COMMENT '知识ID',
    interaction_type VARCHAR(20) NOT NULL COMMENT '交互类型：FAVORITE/SUGGESTION/LIKE/DISLIKE',
    content TEXT COMMENT '交互内容(建议内容等)',
    created_time DATETIME NOT NULL COMMENT '创建时间'
);
```

### 2.8 搜索历史表 (search_history)
```sql
CREATE TABLE search_history (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL COMMENT '用户ID',
    query VARCHAR(500) NOT NULL COMMENT '搜索关键词',
    search_time DATETIME NOT NULL COMMENT '搜索时间',
    result_count INT COMMENT '结果数量'
);
```

#### 2.8.1 MyBatis Plus实体类示例
```java
// 用户实体类
@Data
@TableName("users")
public class User {
    @TableId(type = IdType.AUTO)
    private Long id;
    
    private String username;
    private String email;
    private String role;
    private Integer status;
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createdTime;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updatedTime;
    
    @TableLogic
    private Integer deleted;
}

// 类目实体类
@Data
@TableName("categories")
public class Category {
    @TableId(type = IdType.AUTO)
    private Long id;
    
    private String name;
    private Integer level;
    private Long parentId;
    private Integer sortOrder;
    private Integer status;
    private String description;
    
    private String createdBy;
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createdTime;
    
    private String updatedBy;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updatedTime;
    
    @TableLogic
    private Integer deleted;
}

// 知识实体类
@Data
@TableName("knowledge")
public class Knowledge {
    @TableId(type = IdType.AUTO)
    private Long id;
    
    private String name;
    private String description;
    private Long categoryId;
    
    @TableField(typeHandler = JacksonTypeHandler.class)
    private List<String> tags;
    
    private LocalDateTime effectiveStartTime;
    private LocalDateTime effectiveEndTime;
    private Integer status;
    
    private String createdBy;
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createdTime;
    
    private String updatedBy;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updatedTime;
    
    private Integer searchCount;
    private Integer downloadCount;
    
    @TableLogic
    private Integer deleted;
}
```

#### 2.8.2 MyBatis Plus Mapper示例
```java
// 用户Mapper
@Mapper
public interface UserMapper extends BaseMapper<User> {
    // 自定义查询方法
    @Select("SELECT * FROM users WHERE email = #{email} AND deleted = 0")
    User findByEmail(@Param("email") String email);
    
    // 分页查询
    @Select("SELECT * FROM users WHERE role = #{role} AND deleted = 0")
    IPage<User> selectPageByRole(IPage<User> page, @Param("role") String role);
}

// 类目Mapper
@Mapper
public interface CategoryMapper extends BaseMapper<Category> {
    // 获取类目树
    @Select("SELECT * FROM categories WHERE deleted = 0 ORDER BY sort_order ASC")
    List<Category> selectAllCategories();
    
    // 获取子类目
    @Select("SELECT * FROM categories WHERE parent_id = #{parentId} AND deleted = 0 ORDER BY sort_order ASC")
    List<Category> selectChildrenByParentId(@Param("parentId") Long parentId);
    
    // 检查是否有子类目
    @Select("SELECT COUNT(*) FROM categories WHERE parent_id = #{parentId} AND deleted = 0")
    Integer countChildrenByParentId(@Param("parentId") Long parentId);
}

// 知识Mapper
@Mapper
public interface KnowledgeMapper extends BaseMapper<Knowledge> {
    // 复杂查询
    @Select("SELECT k.*, c.name as categoryName FROM knowledge k " +
            "LEFT JOIN categories c ON k.category_id = c.id " +
            "WHERE k.deleted = 0 AND k.status = 1")
    List<KnowledgeVO> selectKnowledgeWithCategory();
    
    // 统计查询
    @Select("SELECT COUNT(*) FROM knowledge WHERE category_id = #{categoryId} AND deleted = 0")
    Integer countByCategory(@Param("categoryId") Long categoryId);
}
```

#### 2.8.3 Service层示例
```java
@Service
public class UserService extends ServiceImpl<UserMapper, User> {
    
    public User findByEmail(String email) {
        return baseMapper.findByEmail(email);
    }
    
    public IPage<User> getUsersByRole(String role, int page, int size) {
        Page<User> pageParam = new Page<>(page, size);
        return baseMapper.selectPageByRole(pageParam, role);
    }
    
    // 重写保存方法，添加业务逻辑
    @Override
    public boolean save(User user) {
        // 检查用户名是否已存在
        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(User::getUsername, user.getUsername());
        if (baseMapper.selectCount(wrapper) > 0) {
            throw new BusinessException("用户名已存在");
        }
        return super.save(user);
    }
}

// 类目Service
@Service
public class CategoryService extends ServiceImpl<CategoryMapper, Category> {
    
    // 创建类目
    @Transactional
    public Category createCategory(CategoryDTO dto, String currentUser) {
        Category category = new Category();
        BeanUtils.copyProperties(dto, category);
        category.setCreatedBy(currentUser);
        
        // 验证父类目是否存在
        if (dto.getParentId() != null) {
            Category parent = getById(dto.getParentId());
            if (parent == null) {
                throw new BusinessException("父类目不存在");
            }
            category.setLevel(parent.getLevel() + 1);
        } else {
            category.setLevel(1);
        }
        
        save(category);
        return category;
    }
    
    // 更新类目
    @Transactional
    public Category updateCategory(Long id, CategoryDTO dto, String currentUser) {
        Category category = getById(id);
        if (category == null) {
            throw new BusinessException("类目不存在");
        }
        
        // 记录变更历史
        CategoryChangeLog changeLog = new CategoryChangeLog();
        changeLog.setCategoryId(id);
        changeLog.setChangeType("UPDATE");
        changeLog.setOldData(JSON.toJSONString(category));
        changeLog.setChangeReason(dto.getChangeReason());
        changeLog.setChangedBy(currentUser);
        changeLog.setChangedTime(LocalDateTime.now());
        categoryChangeLogService.save(changeLog);
        
        // 更新类目
        BeanUtils.copyProperties(dto, category);
        category.setUpdatedBy(currentUser);
        updateById(category);
        
        return category;
    }
    
    // 删除类目
    @Transactional
    public void deleteCategory(Long id, String currentUser) {
        Category category = getById(id);
        if (category == null) {
            throw new BusinessException("类目不存在");
        }
        
        // 检查是否有子类目
        if (baseMapper.countChildrenByParentId(id) > 0) {
            throw new BusinessException("存在子类目，无法删除");
        }
        
        // 检查是否有关联的知识
        LambdaQueryWrapper<Knowledge> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(Knowledge::getCategoryId, id);
        if (knowledgeMapper.selectCount(wrapper) > 0) {
            throw new BusinessException("存在关联知识，无法删除");
        }
        
        // 记录删除历史
        CategoryChangeLog changeLog = new CategoryChangeLog();
        changeLog.setCategoryId(id);
        changeLog.setChangeType("DELETE");
        changeLog.setOldData(JSON.toJSONString(category));
        changeLog.setChangeReason("删除类目");
        changeLog.setChangedBy(currentUser);
        changeLog.setChangedTime(LocalDateTime.now());
        categoryChangeLogService.save(changeLog);
        
        // 执行删除
        removeById(id);
    }
    
    // 获取类目树
    public List<CategoryTreeVO> getCategoryTree() {
        List<Category> allCategories = baseMapper.selectAllCategories();
        return buildCategoryTree(allCategories, null);
    }
    
    // 构建类目树
    private List<CategoryTreeVO> buildCategoryTree(List<Category> allCategories, Long parentId) {
        List<CategoryTreeVO> tree = new ArrayList<>();
        
        for (Category category : allCategories) {
            if (Objects.equals(category.getParentId(), parentId)) {
                CategoryTreeVO node = new CategoryTreeVO();
                BeanUtils.copyProperties(category, node);
                node.setChildren(buildCategoryTree(allCategories, category.getId()));
                tree.add(node);
            }
        }
        
        return tree;
    }
}
```
```

## 3. Java API设计

### 3.1 用户认证模块

> **说明**: Token默认过期时间为7天（604800秒）

#### 3.1.0 JWT Token验证机制
```java
@Component
public class JwtTokenProvider {
    
    @Value("${jwt.secret}")
    private String jwtSecret;
    
    @Value("${jwt.expiration}")
    private long jwtExpiration;
    
    // 生成Token
    public String generateToken(String username, String role) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpiration * 1000);
        
        return Jwts.builder()
                .setSubject(username)
                .claim("role", role)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(SignatureAlgorithm.HS512, jwtSecret)
                .compact();
    }
    
    // 验证Token
    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(token);
            return true;
        } catch (SignatureException ex) {
            log.error("Invalid JWT signature");
        } catch (MalformedJwtException ex) {
            log.error("Invalid JWT token");
        } catch (ExpiredJwtException ex) {
            log.error("Expired JWT token");
        } catch (UnsupportedJwtException ex) {
            log.error("Unsupported JWT token");
        } catch (IllegalArgumentException ex) {
            log.error("JWT claims string is empty");
        }
        return false;
    }
    
    // 从Token中获取用户名
    public String getUsernameFromToken(String token) {
        Claims claims = Jwts.parser()
                .setSigningKey(jwtSecret)
                .parseClaimsJws(token)
                .getBody();
        return claims.getSubject();
    }
    
    // 从Token中获取角色
    public String getRoleFromToken(String token) {
        Claims claims = Jwts.parser()
                .setSigningKey(jwtSecret)
                .parseClaimsJws(token)
                .getBody();
        return claims.get("role", String.class);
    }
}

#### 3.1.0.1 JWT拦截器
```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Autowired
    private JwtTokenProvider tokenProvider;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) throws ServletException, IOException {
        try {
            String jwt = getJwtFromRequest(request);
            
            if (StringUtils.hasText(jwt) && tokenProvider.validateToken(jwt)) {
                String username = tokenProvider.getUsernameFromToken(jwt);
                String role = tokenProvider.getRoleFromToken(jwt);
                
                // 设置认证信息到SecurityContext
                UsernamePasswordAuthenticationToken authentication = 
                    new UsernamePasswordAuthenticationToken(username, null, 
                        Collections.singletonList(new SimpleGrantedAuthority("ROLE_" + role)));
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception ex) {
            log.error("Could not set user authentication in security context", ex);
        }
        
        filterChain.doFilter(request, response);
    }
    
    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

#### 3.1.0.2 JWT依赖配置
```xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>
```

#### 3.1.1 用户登录
```
POST /api/auth/login
Content-Type: application/json

Request:
{
  "username": "string",
  "password": "string"
}

Response:
{
  "success": boolean,
  "token": "string",
  "expiresIn": "long",
  "user": {
    "id": "string",
    "email": "string",
    "role": "string"
  }
}
```

### 3.2 三级类目管理模块

#### 3.2.1 创建类目
```
POST /api/categories
Content-Type: application/json

Request:
{
  "name": "string", 
  "level": "int",
  "parentId": "long",
  "sortOrder": "int",
  "description": "string"
}

Response:
{
  "id": "long",
  "name": "string",
  "level": "int",
  "parentId": "long",
  "sortOrder": "int",
  "description": "string",
  "createdBy": "string",
  "createdTime": "datetime"
}
```

#### 3.2.2 更新类目
```
PUT /api/categories/{id}
Content-Type: application/json

Request:
{
  "name": "string",
  "sortOrder": "int",
  "description": "string",
  "changeReason": "string"
}

Response:
{
  "id": "long",
  "name": "string",
  "level": "int",
  "parentId": "long",
  "sortOrder": "int",
  "description": "string",
  "updatedBy": "string",
  "updatedTime": "datetime"
}
```

#### 3.2.3 删除类目
```
DELETE /api/categories/{id}

Response:
{
  "success": boolean,
  "message": "string"
}
```

#### 3.2.4 获取类目详情
```
GET /api/categories/{id}

Response:
{
  "id": "long",
  "name": "string",
  "level": "int",
  "parentId": "long",
  "sortOrder": "int",
  "description": "string",
  "status": "int",
  "createdBy": "string",
  "createdTime": "datetime",
  "updatedBy": "string",
  "updatedTime": "datetime"
}
```

#### 3.2.5 获取类目树
```
GET /api/categories/tree

Response:
{
  "categories": [
    {
      "id": "long",
      "name": "string",
      "level": "int",
      "children": [
        {
          "id": "long",
          "name": "string",
          "level": "int",
          "children": [...]
        }
      ]
    }
  ]
}
```

#### 3.2.3 获取类目变更历史
```
GET /api/categories/{id}/change-logs?page={page}&size={size}

Response:
{
  "total": "long",
  "changeLogs": [
    {
      "id": "long",
      "changeType": "string",
      "oldData": "object",
      "newData": "object", 
      "changeReason": "string",
      "changedBy": "string",
      "changedTime": "datetime"
    }
  ]
}
```

### 3.3 知识管理模块

#### 3.3.1 创建知识
```
POST /api/knowledge
Content-Type: application/json

Request:
{
  "name": "string",
  "description": "string",
  "categoryId": "long",
  "tags": ["string"],
  "effectiveTime": {
    "startTime": "datetime",
    "endTime": "datetime"
  },
  "attachments": [
    {
      "fileName": "string",
      "filePath": "string",
      "fileSize": "long"
    }
  ]
}

Response:
{
  "id": "long",
  "name": "string",
  "description": "string",
  "categoryId": "long",
  "tags": ["string"],
  "effectiveTime": "object",
  "attachments": ["object"],
  "createdBy": "string",
  "createdTime": "datetime"
}
```

#### 3.3.2 更新知识
```
PUT /api/knowledge/{id}
Content-Type: application/json

Request:
{
  "name": "string",
  "description": "string",
  "categoryId": "long",
  "tags": ["string"],
  "effectiveTime": "object",
  "attachments": ["object"],
  "changeReason": "string"
}

Response:
{
  "id": "long",
  "versionNumber": "int",
  "name": "string",
  "description": "string",
  "categoryId": "long",
  "tags": ["string"],
  "effectiveTime": "object",
  "attachments": ["object"],
  "updatedBy": "string",
  "updatedTime": "datetime"
}
```

#### 3.3.3 获取知识版本历史
```
GET /api/knowledge/{id}/versions?page={page}&size={size}

Response:
{
  "total": "long",
  "versions": [
    {
      "id": "long",
      "versionNumber": "int",
      "name": "string",
      "description": "string",
      "categoryId": "long",
      "tags": ["string"],
      "effectiveTime": "object",
      "createdBy": "string",
      "createdTime": "datetime",
      "changeReason": "string"
    }
  ]
}
```

### 3.4 搜索模块

#### 3.4.1 搜索输入联想
```
GET /api/search/suggest?q={query}

Response:
{
  "suggestions": ["string"]
}
```

#### 3.4.2 知识搜索
```
POST /api/search
Content-Type: application/json

Request:
{
  "query": "string",
  "page": "int",
  "size": "int",
  "categoryId": "long",
  "tags": ["string"]
}

Response:
{
  "total": "long",
  "esResults": [
    {
      "id": "string",
      "name": "string",
      "description": "string",
      "categoryName": "string",
      "tags": ["string"],
      "score": "float"
    }
  ],
  "ragResults": [
    {
      "id": "string",
      "knowledgeId": "string",
      "content": "string",
      "score": "float",
      "source": "string"
    }
  ]
}
```

#### 3.4.3 获取推荐问题
```
GET /api/search/recommendations

Response:
{
  "recommendations": ["string"]
}
```

### 3.5 统计和排行榜模块

#### 3.5.1 获取热门知识
```
GET /api/statistics/popular

Response:
{
  "popularKnowledge": [
    {
      "id": "string",
      "name": "string",
      "searchCount": "int"
    }
  ]
}
```

#### 3.5.2 获取最新知识
```
GET /api/statistics/latest

Response:
{
  "latestKnowledge": [
    {
      "id": "string",
      "name": "string",
      "createTime": "datetime"
    }
  ]
}
```

#### 3.5.3 获取下载排行
```
GET /api/statistics/downloads

Response:
{
  "topDownloads": [
    {
      "id": "string",
      "name": "string",
      "downloadCount": "int"
    }
  ]
}
```

### 3.6 文件管理模块

> **说明**: 文件预览由前端根据文件类型自行处理，后端只提供文件下载接口。前端可以：
> - 对于图片、PDF等可直接在浏览器预览的文件，直接使用下载链接进行预览
> - 对于Word、Excel、PPT等文件，可以转换为PDF后预览或使用第三方预览服务
> - 对于视频、音频文件，使用HTML5原生播放器

#### 3.6.1 文件上传
```
POST /api/files/upload
Content-Type: multipart/form-data

Request:
file: File

Response:
{
  "fileId": "string",
  "fileName": "string",
  "fileSize": "long",
  "fileType": "string"
}
```

#### 3.6.2 文件下载
```
GET /api/files/download/{fileId}

Response:
File stream
```

### 3.7 用户交互模块

#### 3.7.1 收藏知识
```
POST /api/interaction/favorite
Content-Type: application/json

Request:
{
  "knowledgeId": "string"
}

Response:
{
  "success": boolean
}
```

#### 3.7.2 提交修改建议
```
POST /api/interaction/suggestion
Content-Type: application/json

Request:
{
  "knowledgeId": "string",
  "suggestion": "string"
}

Response:
{
  "success": boolean
}
```

#### 3.7.3 点赞/点踩RAG结果
```
POST /api/interaction/feedback
Content-Type: application/json

Request:
{
  "ragResultId": "string",
  "type": "LIKE|DISLIKE"
}

Response:
{
  "success": boolean
}
```

### 3.8 智能问答模块（流式交互）

> **说明**: Java负责与前端进行流式交互（Server-Sent Events），Python负责与本地LLM进行HTTP调用。Java接收到前端问题后，先调用Python的RAG检索服务获取相关知识，再调用Python的LLM生成服务获取回答，最后以流式方式返回给前端。

#### 3.8.1 流式对话
```
POST /api/chat/stream
Content-Type: application/json
Accept: text/event-stream

Request:
{
  "question": "string",
  "sessionId": "string"
}

Response (Server-Sent Events):
event: start
data: {"type": "start", "content": "开始生成回答..."}

event: searching
data: {"type": "searching", "content": "正在检索相关知识..."}

event: sources
data: {"type": "sources", "content": [{"knowledgeId": "string", "content": "string"}]}

event: chunk
data: {"type": "chunk", "content": "回答内容片段"}

event: complete
data: {"type": "complete", "content": "回答完成"}
```

#### 3.8.2 停止对话
```
POST /api/chat/stop/{sessionId}

Response:
{
  "success": boolean
}
```

## 4. Python API设计

### 4.1 LDAP认证服务

#### 4.1.1 LDAP认证
```
POST /ldap/auth
Content-Type: application/json

Request:
{
  "username": "string",
  "password": "string"
}

Response:
{
  "success": boolean,
  "user": {
    "email": "string",
    "role": "string"
  }
}
```

### 4.2 文档处理服务

#### 4.2.1 文档处理
```
POST /document/process
Content-Type: application/json

Request:
{
  "filePath": "string",
  "knowledgeId": "string",
  "knowledgeName": "string",
  "description": "string",
  "tags": ["string"]
}

Response:
{
  "success": boolean,
  "chunks": "int",
  "processingTime": "float"
}
```

### 4.3 RAG检索服务

#### 4.3.1 向量检索
```
POST /rag/search
Content-Type: application/json

Request:
{
  "query": "string",
  "topK": "int"
}

Response:
{
  "results": [
    {
      "knowledgeId": "string",
      "content": "string",
      "score": "float",
      "metadata": {
        "knowledgeName": "string",
        "description": "string",
        "tags": ["string"],
        "effectiveTime": "object"
      }
    }
  ]
}
```

### 4.4 智能问答服务

#### 4.4.1 LLM对话生成
```
POST /chat/generate
Content-Type: application/json

Request:
{
  "question": "string",
  "context": [
    {
      "knowledgeId": "string",
      "content": "string"
    }
  ]
}

Response:
{
  "answer": "string",
  "sources": [
    {
      "knowledgeId": "string",
      "knowledgeName": "string",
      "content": "string"
    }
  ]
}
```

## 5. 权限控制设计

### 5.1 角色定义
- **ADMIN**: 系统管理员，拥有所有权限
- **CATEGORY_MANAGER**: 类目管理员，可以管理类目
- **KNOWLEDGE_MANAGER**: 知识管理员，可以管理知识
- **USER**: 普通用户，可以搜索和查看知识

### 5.2 权限矩阵
| 功能模块 | ADMIN | CATEGORY_MANAGER | KNOWLEDGE_MANAGER | USER |
|---------|-------|------------------|-------------------|------|
| 类目管理 | ✓ | ✓ | ✗ | ✗ |
| 知识管理 | ✓ | ✗ | ✓ | ✗ |
| 知识搜索 | ✓ | ✓ | ✓ | ✓ |
| 智能问答 | ✓ | ✓ | ✓ | ✓ |
| 文件管理 | ✓ | ✗ | ✓ | ✓ |
| 用户交互 | ✓ | ✓ | ✓ | ✓ |

## 6. 性能优化设计

### 6.1 缓存策略

#### 6.1.1 缓存需求分析
经过分析，本系统大部分场景**不需要缓存**，原因如下：

1. **类目树结构**
   - 数据量小，查询频率不高
   - 变更频率低，直接查数据库即可
   - 缓存收益不大

2. **知识搜索**
   - 主要依赖ES，ES自带缓存机制
   - 搜索结果个性化强，缓存命中率低
   - 实时性要求高，缓存可能影响准确性

3. **用户会话**
   - 使用JWT Token，无状态设计
   - 服务器端需要存储JWT密钥用于验证token
   - 可以配置token黑名单（可选，用于主动失效）

4. **文件下载**
   - 直接文件流，无需缓存
   - 文件内容变化频繁

#### 6.1.2 可选的轻量级缓存
如果后续性能需要，可考虑以下场景：

1. **热门搜索词统计**
   - 缓存最近1小时的热门搜索词
   - 用于推荐问题功能
   - 数据量小，更新频率低

2. **系统配置信息**
   - 缓存系统参数配置
   - 如文件上传限制、支持的格式等
   - 变更频率极低

#### 6.1.3 缓存实现方案
如需缓存，推荐使用Spring Boot内置的简单缓存：

```java
// 使用@Cacheable注解
@Cacheable(value = "hotSearches", key = "#date")
public List<String> getHotSearches(LocalDate date) {
    // 查询热门搜索词
}

// 使用@CacheEvict注解清除缓存
@CacheEvict(value = "hotSearches", allEntries = true)
public void clearHotSearchesCache() {
    // 清除缓存
}
```

**结论**: 本系统设计为无缓存架构，主要依赖数据库和ES的自身优化机制。

### 6.4 数据一致性保证

#### 6.4.1 外键约束替代方案
由于不使用数据库外键约束，需要在应用层保证数据一致性：

1. **类目删除检查**
   ```java
   @Service
   public class CategoryService {
       public void deleteCategory(Long categoryId) {
           // 检查是否有子类目
           LambdaQueryWrapper<Category> wrapper = new LambdaQueryWrapper<>();
           wrapper.eq(Category::getParentId, categoryId);
           if (baseMapper.selectCount(wrapper) > 0) {
               throw new BusinessException("存在子类目，无法删除");
           }
           
           // 检查是否有关联的知识
           LambdaQueryWrapper<Knowledge> knowledgeWrapper = new LambdaQueryWrapper<>();
           knowledgeWrapper.eq(Knowledge::getCategoryId, categoryId);
           if (knowledgeMapper.selectCount(knowledgeWrapper) > 0) {
               throw new BusinessException("存在关联知识，无法删除");
           }
           
           // 执行删除
           baseMapper.deleteById(categoryId);
       }
   }
   ```

2. **知识删除检查**
   ```java
   @Service
   public class KnowledgeService {
       public void deleteKnowledge(Long knowledgeId) {
           // 检查是否存在附件
           LambdaQueryWrapper<Attachment> wrapper = new LambdaQueryWrapper<>();
           wrapper.eq(Attachment::getKnowledgeId, knowledgeId);
           if (attachmentMapper.selectCount(wrapper) > 0) {
               throw new BusinessException("存在附件，请先删除附件");
           }
           
           // 执行删除
           baseMapper.deleteById(knowledgeId);
       }
   }
   ```

3. **用户删除检查**
   ```java
   @Service
   public class UserService {
       public void deleteUser(Long userId) {
           // 检查是否有交互记录
           LambdaQueryWrapper<UserInteraction> wrapper = new LambdaQueryWrapper<>();
           wrapper.eq(UserInteraction::getUserId, userId);
           if (userInteractionMapper.selectCount(wrapper) > 0) {
               throw new BusinessException("存在用户交互记录，无法删除");
           }
           
           // 检查是否有搜索历史
           LambdaQueryWrapper<SearchHistory> historyWrapper = new LambdaQueryWrapper<>();
           historyWrapper.eq(SearchHistory::getUserId, userId);
           if (searchHistoryMapper.selectCount(historyWrapper) > 0) {
               throw new BusinessException("存在搜索历史，无法删除");
           }
           
           // 执行删除
           baseMapper.deleteById(userId);
       }
   }
   ```

#### 6.4.2 事务管理
使用Spring事务管理确保数据操作的原子性：

```java
@Service
@Transactional
public class KnowledgeService {
    
    @Transactional(rollbackFor = Exception.class)
    public void createKnowledge(KnowledgeDTO dto) {
        // 1. 验证类目是否存在
        Category category = categoryService.getById(dto.getCategoryId());
        if (category == null) {
            throw new BusinessException("类目不存在");
        }
        
        // 2. 保存知识
        Knowledge knowledge = new Knowledge();
        BeanUtils.copyProperties(dto, knowledge);
        save(knowledge);
        
        // 3. 保存附件
        if (dto.getAttachments() != null) {
            for (AttachmentDTO attachmentDTO : dto.getAttachments()) {
                Attachment attachment = new Attachment();
                attachment.setKnowledgeId(knowledge.getId());
                BeanUtils.copyProperties(attachmentDTO, attachment);
                attachmentMapper.insert(attachment);
            }
        }
        
        // 4. 调用Python服务处理文档
        documentProcessService.processDocument(knowledge.getId(), dto.getAttachments());
    }
}
```

#### 6.1.4 MyBatis Plus配置类
```java
@Configuration
@MapperScan("com.knowledge.mapper")
public class MybatisPlusConfig {
    
    // 分页插件
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }
    
    // SQL性能分析插件（开发环境使用）
    @Bean
    @Profile({"dev", "test"})
    public PerformanceInterceptor performanceInterceptor() {
        PerformanceInterceptor interceptor = new PerformanceInterceptor();
        interceptor.setMaxTime(1000); // 超过1秒的SQL会打印警告
        return interceptor;
    }
    
    // 自动填充处理器
    @Bean
    public MetaObjectHandler metaObjectHandler() {
        return new MetaObjectHandler() {
            @Override
            public void insertFill(MetaObject metaObject) {
                this.strictInsertFill(metaObject, "createdTime", LocalDateTime.class, LocalDateTime.now());
                this.strictInsertFill(metaObject, "updatedTime", LocalDateTime.class, LocalDateTime.now());
            }
            
            @Override
            public void updateFill(MetaObject metaObject) {
                this.strictUpdateFill(metaObject, "updatedTime", LocalDateTime.class, LocalDateTime.now());
            }
        };
    }
}
```

### 6.2 数据库优化
- **MySQL分区策略**:
  - 知识表按创建时间分区（按月分区）
  - 搜索历史表按时间分区（按月分区）
  - 附件表按上传时间分区（按月分区）

- **索引优化**:
  ```sql
  -- 用户表索引
  CREATE INDEX idx_users_email ON users(email);
  CREATE INDEX idx_users_username ON users(username);
  
  -- 知识表索引
  CREATE INDEX idx_knowledge_category ON knowledge(category_id);
  CREATE INDEX idx_knowledge_created_time ON knowledge(created_time);
  CREATE INDEX idx_knowledge_status ON knowledge(status);
  CREATE INDEX idx_knowledge_search_count ON knowledge(search_count);
  
  -- 类目表索引
  CREATE INDEX idx_categories_parent ON categories(parent_id);
  CREATE INDEX idx_categories_level ON categories(level);
  
  -- 搜索历史表索引
  CREATE INDEX idx_search_history_user_time ON search_history(user_id, search_time);
  CREATE INDEX idx_search_history_query ON search_history(query);
  ```

- **MyBatis Plus优化**:
  - 使用分页插件优化分页查询
  - 配置SQL性能分析插件
  - 使用批量操作提高性能

### 6.3 搜索优化
- ES分片和副本配置
- 搜索结果缓存
- 异步索引更新

## 7. 安全设计

### 7.1 认证安全
- JWT Token认证
- Token过期时间设置
- 密码加密存储

### 7.2 数据安全
- SQL注入防护
- XSS攻击防护
- 文件上传安全检查

### 7.3 接口安全
- 接口限流
- 权限验证
- 参数校验

## 8. 已实现功能

### 8.1 用户认证模块
- **LDAP集成**: 通过Python服务调用LDAP进行用户验证
- **JWT Token**: 无状态认证，支持用户信息自动同步
- **用户管理**: 自动创建/更新用户信息

### 8.2 智能问答模块
- **RAG对话**: 通过Python服务实现RAG智能问答
- **知识引用**: 返回相关的知识引用信息
- **流式响应**: 支持SSE流式响应（预留接口）
- **会话管理**: 支持会话ID管理

### 8.3 Python服务
- **LDAP验证**: `/api/ldap/validate` - 用户LDAP验证
- **RAG对话**: `/api/rag/chat` - 智能问答服务
- **FastAPI框架**: 高性能异步Web框架
- **模拟实现**: 当前为模拟实现，可替换为真实服务

### 8.4 Java-Python通信
- **HTTP REST**: 使用RestTemplate进行服务间通信
- **配置化**: 支持Python服务URL配置
- **异常处理**: 完善的错误处理和重试机制
- **日志记录**: 详细的服务调用日志

## 9. 监控和日志

### 9.1 业务监控
- 搜索量监控
- 问答质量监控
- 用户行为分析

### 9.2 系统监控
- 服务健康检查
- 性能指标监控
- 错误日志收集

### 9.3 审计日志
- 用户操作日志
- 数据变更日志
- 系统访问日志 