#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
åŽ†å²ç³»ç»Ÿæ•°æ®è¿ç§»å·¥å…·
ä»Ž SQLite3 è¿ç§»åˆ° MySQL
"""

import sqlite3
import mysql.connector
import json
import re
from datetime import datetime
import os
import sys

class LegacyDataMigration:
    def __init__(self, sqlite_db_path, mysql_config):
        self.sqlite_db_path = sqlite_db_path
        self.mysql_config = mysql_config
        self.mysql_conn = None
        self.sqlite_conn = None
        self.id_mapping = {}  # å­˜å‚¨æ—§IDåˆ°æ–°IDçš„æ˜ å°„
        
    def connect_databases(self):
        """è¿žæŽ¥æ•°æ®åº“"""
        try:
            # è¿žæŽ¥ SQLite
            self.sqlite_conn = sqlite3.connect(self.sqlite_db_path)
            print(f"âœ… å·²è¿žæŽ¥ SQLite æ•°æ®åº“: {self.sqlite_db_path}")
            
            # è¿žæŽ¥ MySQLï¼ˆå¼ºåˆ¶ä½¿ç”¨ utf8mb4ï¼Œé¿å…ä¸­æ–‡/emoji å†™å…¥æŠ¥é”™ 1366ï¼‰
            self.mysql_conn = mysql.connector.connect(
                charset='utf8mb4',
                collation='utf8mb4_unicode_ci',
                use_unicode=True,
                get_warnings=True,
                **self.mysql_config
            )
            # åŒä¿é™©ï¼šè®¾ç½®ä¼šè¯å­—ç¬¦é›†
            try:
                cur = self.mysql_conn.cursor()
                cur.execute("SET NAMES utf8mb4")
                cur.execute("SET CHARACTER SET utf8mb4")
                cur.execute("SET character_set_connection=utf8mb4")
                cur.close()
            except Exception:
                pass
            print(f"âœ… å·²è¿žæŽ¥ MySQL æ•°æ®åº“: {self.mysql_config['database']}")
            
        except Exception as e:
            print(f"âŒ æ•°æ®åº“è¿žæŽ¥å¤±è´¥: {e}")
            sys.exit(1)

    def ensure_target_schema(self):
        """ç¡®ä¿ç›®æ ‡åº“å­˜åœ¨è¿ç§»æ‰€éœ€çš„æ–°å­—æ®µï¼ˆå¹‚ç­‰ï¼‰ã€‚"""
        cursor = self.mysql_conn.cursor()
        add_columns_sql = [
            "ALTER TABLE users ADD COLUMN display_name VARCHAR(150) NULL",
            "ALTER TABLE users ADD COLUMN profile_picture VARCHAR(255) NULL",
            "ALTER TABLE users ADD COLUMN password VARCHAR(255) NULL",
            "ALTER TABLE users ADD COLUMN last_login DATETIME NULL",
            "ALTER TABLE users ADD COLUMN date_joined DATETIME NULL",
        ]
        for stmt in add_columns_sql:
            try:
                cursor.execute(stmt)
            except Exception as e:
                # å·²å­˜åœ¨åˆ™å¿½ç•¥
                if 'Duplicate column name' in str(e) or 'exists' in str(e).lower():
                    continue
                raise
        self.mysql_conn.commit()

    def _sqlite_columns(self, table_name: str):
        """è¯»å– SQLite è¡¨å­—æ®µåé›†åˆã€‚"""
        cur = self.sqlite_conn.cursor()
        cur.execute(f"PRAGMA table_info('{table_name}')")
        return {row[1] for row in cur.fetchall()}  # row[1] is column name
    
    def parse_path_to_hierarchy(self, path):
        """
        è§£æž path ç¼–ç ä¸ºå±‚çº§ç»“æž„
        ä¾‹å¦‚: 00010001000P00030004 -> [1, 1, 16, 3, 4]
        """
        if not path:
            return []
        
        # æŒ‰ 000 åˆ†å‰² path
        parts = path.split('000')
        hierarchy = []
        
        for part in parts:
            if not part:
                continue
            # å°†å­—æ¯è½¬æ¢ä¸ºæ•°å­—
            if part.isdigit():
                hierarchy.append(int(part))
            else:
                # å­—æ¯è½¬æ•°å­—: A=10, B=11, ..., P=16, ...
                hierarchy.append(ord(part) - ord('A') + 10)
        
        return hierarchy
    
    def migrate_users(self):
        """è¿ç§»ç”¨æˆ·æ•°æ®"""
        print("\nðŸ”„ å¼€å§‹è¿ç§»ç”¨æˆ·æ•°æ®...")
        
        cursor = self.sqlite_conn.cursor()
        cols = self._sqlite_columns('app_user')
        select_fields = [
            'id', 'username', 'email', 'first_name', 'last_name',
            ('password' if 'password' in cols else "NULL AS password"),
            ('last_login' if 'last_login' in cols else "NULL AS last_login"),
            ('date_joined' if 'date_joined' in cols else "datetime('now') AS date_joined"),
            ('is_active' if 'is_active' in cols else "1 AS is_active"),
            ('display_name' if 'display_name' in cols else "NULL AS display_name"),
            ('profile_picture' if 'profile_picture' in cols else "NULL AS profile_picture"),
            ('role' if 'role' in cols else "NULL AS role"),
        ]
        cursor.execute(f"SELECT {', '.join(select_fields)} FROM app_user")
        users = cursor.fetchall()
        
        mysql_cursor = self.mysql_conn.cursor()
        
        for user in users:
            old_id, username, email, first_name, last_name, password, last_login, date_joined, is_active, display_name, profile_picture, role = user
            
            # ç”Ÿæˆæ–°çš„ç”¨æˆ·ID
            mysql_cursor.execute("SELECT COALESCE(MAX(id), 0) + 1 FROM users")
            new_id = mysql_cursor.fetchone()[0]
            
            # æ’å…¥ç”¨æˆ·æ•°æ®
            insert_sql = """
            INSERT INTO users (id, username, email, staffid, system_role, display_name, profile_picture, role, password, last_login, status, created_time, deleted)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            
            values = (
                new_id,
                username or '',
                email or '',
                username or '',  # ä½¿ç”¨ username ä½œä¸º staffid
                'ADMIN' if (role or '').upper() == 'ADMIN' else 'USER',  # é»˜è®¤æˆ–æŒ‰åŽ†å²role
                display_name,
                profile_picture,
                role,
                password,
                last_login,
                1 if is_active else 0,
                date_joined or datetime.now(),
                0
            )
            
            mysql_cursor.execute(insert_sql, values)
            self.id_mapping[f"user_{old_id}"] = new_id
            
        self.mysql_conn.commit()
        print(f"âœ… ç”¨æˆ·æ•°æ®è¿ç§»å®Œæˆ: {len(users)} æ¡è®°å½•")
    
    def migrate_categories(self):
        """è¿ç§»åˆ†ç±»æ•°æ® (è½¬æ¢ä¸º knowledge è¡¨çš„ folder ç±»åž‹)"""
        print("\nðŸ”„ å¼€å§‹è¿ç§»åˆ†ç±»æ•°æ®...")
        
        cursor = self.sqlite_conn.cursor()
        cols = self._sqlite_columns('app_category')
        select_fields = [
            'id', 'name', 'path', 'depth',
            ('created' if 'created' in cols else "datetime('now') AS created"),
            ('updated' if 'updated' in cols else "NULL AS updated"),
        ]
        cursor.execute(f"SELECT {', '.join(select_fields)} FROM app_category ORDER BY path")
        categories = cursor.fetchall()
        
        mysql_cursor = self.mysql_conn.cursor()
        
        # å…ˆåˆ›å»ºæ‰€æœ‰åˆ†ç±»èŠ‚ç‚¹ï¼Œä¸è®¾ç½® parent_id
        for category in categories:
            old_id, name, path, depth, created, updated = category
            
            # ç”Ÿæˆæ–°çš„ID
            mysql_cursor.execute("SELECT COALESCE(MAX(id), 0) + 1 FROM knowledge")
            new_id = mysql_cursor.fetchone()[0]
            
            insert_sql = """
            INSERT INTO knowledge (id, name, parent_id, node_type, created_by, created_time, updated_time, status, deleted)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            
            values = (
                new_id,
                name or '',
                None,  # å…ˆä¸è®¾ç½® parent_id
                'folder',
                'admin',  # é»˜è®¤åˆ›å»ºäºº
                created or datetime.now(),
                updated,
                1,
                0
            )
            
            mysql_cursor.execute(insert_sql, values)
            self.id_mapping[f"category_{old_id}"] = new_id
            
        self.mysql_conn.commit()
        
        # çŽ°åœ¨è®¾ç½® parent_id å…³ç³»
        for category in categories:
            old_id, name, path, depth, created, updated = category
            new_id = self.id_mapping[f"category_{old_id}"]
            
            # è§£æž path èŽ·å–çˆ¶èŠ‚ç‚¹
            hierarchy = self.parse_path_to_hierarchy(path)
            if len(hierarchy) > 1:
                # æ‰¾åˆ°çˆ¶èŠ‚ç‚¹çš„ path
                parent_path = '000'.join([''] + [str(h) if h < 10 else chr(h - 10 + ord('A')) for h in hierarchy[:-1]])
                
                # æŸ¥æ‰¾çˆ¶èŠ‚ç‚¹
                cursor.execute("SELECT id FROM app_category WHERE path = ?", (parent_path,))
                parent_result = cursor.fetchone()
                if parent_result:
                    parent_old_id = parent_result[0]
                    parent_new_id = self.id_mapping[f"category_{parent_old_id}"]
                    
                    # æ›´æ–° parent_id
                    update_sql = "UPDATE knowledge SET parent_id = %s WHERE id = %s"
                    mysql_cursor.execute(update_sql, (parent_new_id, new_id))
        
        self.mysql_conn.commit()
        print(f"âœ… åˆ†ç±»æ•°æ®è¿ç§»å®Œæˆ: {len(categories)} æ¡è®°å½•")
    
    def migrate_content(self):
        """è¿ç§»å†…å®¹æ•°æ®"""
        print("\nðŸ”„ å¼€å§‹è¿ç§»å†…å®¹æ•°æ®...")
        
        cursor = self.sqlite_conn.cursor()
        cols = self._sqlite_columns('app_contentitem')
        # å…¼å®¹åŽ†å²å‘½åï¼šexpired æˆ– expir_date
        expired_expr = (
            'expired' if 'expired' in cols else (
                'expir_date AS expired' if 'expir_date' in cols else "NULL AS expired"
            )
        )
        select_fields = [
            'id', 'title', 'text',
            ('keywords' if 'keywords' in cols else "NULL AS keywords"),
            ('created' if 'created' in cols else "datetime('now') AS created"),
            ('updated' if 'updated' in cols else "NULL AS updated"),
            expired_expr,
            ('category_id' if 'category_id' in cols else "NULL AS category_id"),
        ]
        cursor.execute(f"SELECT {', '.join(select_fields)} FROM app_contentitem")
        contents = cursor.fetchall()
        
        mysql_cursor = self.mysql_conn.cursor()
        
        for content in contents:
            old_id, title, text, keywords, created, updated, expired, category_id = content
            
            # ç”Ÿæˆæ–°çš„ID
            mysql_cursor.execute("SELECT COALESCE(MAX(id), 0) + 1 FROM knowledge")
            new_id = mysql_cursor.fetchone()[0]
            
            # è½¬æ¢æ ‡ç­¾
            tags = []
            if keywords:
                tags = [tag.strip() for tag in keywords.split(',') if tag.strip()]
            
            # èŽ·å–çˆ¶åˆ†ç±»ID
            parent_id = None
            if category_id and f"category_{category_id}" in self.id_mapping:
                parent_id = self.id_mapping[f"category_{category_id}"]
            
            insert_sql = """
            INSERT INTO knowledge (id, name, description, parent_id, node_type, tags, created_by, created_time, updated_time, effective_end_time, status, deleted)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            
            values = (
                new_id,
                title or '',
                text or '',
                parent_id,
                'doc',
                json.dumps(tags, ensure_ascii=False),
                'admin',
                created or datetime.now(),
                updated,
                expired,
                1,
                0
            )
            
            mysql_cursor.execute(insert_sql, values)
            self.id_mapping[f"content_{old_id}"] = new_id
            
        self.mysql_conn.commit()
        print(f"âœ… å†…å®¹æ•°æ®è¿ç§»å®Œæˆ: {len(contents)} æ¡è®°å½•")
    
    def migrate_uploads(self):
        """è¿ç§»æ–‡ä»¶ä¸Šä¼ æ•°æ®"""
        print("\nðŸ”„ å¼€å§‹è¿ç§»æ–‡ä»¶æ•°æ®...")
        
        cursor = self.sqlite_conn.cursor()
        cursor.execute("SELECT id, file, created, content_item_id FROM app_upload")
        uploads = cursor.fetchall()
        
        mysql_cursor = self.mysql_conn.cursor()
        
        for upload in uploads:
            old_id, file_path, created, content_item_id = upload
            
            # ç”Ÿæˆæ–°çš„ID
            mysql_cursor.execute("SELECT COALESCE(MAX(id), 0) + 1 FROM attachments")
            new_id = mysql_cursor.fetchone()[0]
            
            # èŽ·å–å…³è”çš„çŸ¥è¯†ID
            knowledge_id = None
            if content_item_id and f"content_{content_item_id}" in self.id_mapping:
                knowledge_id = self.id_mapping[f"content_{content_item_id}"]
            
            if not knowledge_id:
                continue  # è·³è¿‡æ²¡æœ‰å…³è”å†…å®¹çš„æ–‡ä»¶
            
            # æå–æ–‡ä»¶åå’Œç±»åž‹
            file_name = os.path.basename(file_path) if file_path else f"file_{old_id}"
            file_type = os.path.splitext(file_name)[1] if file_name else ''
            
            insert_sql = """
            INSERT INTO attachments (id, knowledge_id, file_name, file_path, file_size, file_type, upload_time, deleted)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            """
            
            values = (
                new_id,
                knowledge_id,
                file_name,
                file_path or '',
                0,  # æ–‡ä»¶å¤§å°ï¼Œéœ€è¦å®žé™…è®¡ç®—
                file_type,
                created or datetime.now(),
                0
            )
            
            mysql_cursor.execute(insert_sql, values)
            
        self.mysql_conn.commit()
        print(f"âœ… æ–‡ä»¶æ•°æ®è¿ç§»å®Œæˆ: {len(uploads)} æ¡è®°å½•")
    
    def migrate_feedbacks(self):
        """è¿ç§»åé¦ˆæ•°æ®"""
        print("\nðŸ”„ å¼€å§‹è¿ç§»åé¦ˆæ•°æ®...")
        
        cursor = self.sqlite_conn.cursor()
        cursor.execute("SELECT id, text, created, content_item_id FROM app_feedback")
        feedbacks = cursor.fetchall()
        
        mysql_cursor = self.mysql_conn.cursor()
        
        for feedback in feedbacks:
            old_id, text, created, content_item_id = feedback
            
            # ç”Ÿæˆæ–°çš„ID
            mysql_cursor.execute("SELECT COALESCE(MAX(id), 0) + 1 FROM knowledge_feedbacks")
            new_id = mysql_cursor.fetchone()[0]
            
            # èŽ·å–å…³è”çš„çŸ¥è¯†ID
            knowledge_id = None
            if content_item_id and f"content_{content_item_id}" in self.id_mapping:
                knowledge_id = self.id_mapping[f"content_{content_item_id}"]
            
            if not knowledge_id:
                continue
            
            insert_sql = """
            INSERT INTO knowledge_feedbacks (id, knowledge_id, user_id, content, created_time, deleted)
            VALUES (%s, %s, %s, %s, %s, %s)
            """
            
            values = (
                new_id,
                knowledge_id,
                1,  # é»˜è®¤ç”¨æˆ·ID
                text or '',
                created or datetime.now(),
                0
            )
            
            mysql_cursor.execute(insert_sql, values)
            
        self.mysql_conn.commit()
        print(f"âœ… åé¦ˆæ•°æ®è¿ç§»å®Œæˆ: {len(feedbacks)} æ¡è®°å½•")
    
    def migrate_favorites(self):
        """è¿ç§»æ”¶è—æ•°æ®"""
        print("\nðŸ”„ å¼€å§‹è¿ç§»æ”¶è—æ•°æ®...")
        
        cursor = self.sqlite_conn.cursor()
        cursor.execute("SELECT id, contentitem_id, user_id FROM app_contentitem_user_favourited")
        favorites = cursor.fetchall()
        
        mysql_cursor = self.mysql_conn.cursor()
        
        for favorite in favorites:
            old_id, content_item_id, user_id = favorite
            
            # ç”Ÿæˆæ–°çš„ID
            mysql_cursor.execute("SELECT COALESCE(MAX(id), 0) + 1 FROM knowledge_favorites")
            new_id = mysql_cursor.fetchone()[0]
            
            # èŽ·å–å…³è”çš„çŸ¥è¯†ID
            knowledge_id = None
            if content_item_id and f"content_{content_item_id}" in self.id_mapping:
                knowledge_id = self.id_mapping[f"content_{content_item_id}"]
            
            if not knowledge_id:
                continue
            
            # èŽ·å–ç”¨æˆ·ID
            new_user_id = 1  # é»˜è®¤ç”¨æˆ·ID
            if f"user_{user_id}" in self.id_mapping:
                new_user_id = self.id_mapping[f"user_{user_id}"]
            
            insert_sql = """
            INSERT INTO knowledge_favorites (id, knowledge_id, user_id, created_time, deleted)
            VALUES (%s, %s, %s, %s, %s)
            """
            
            values = (
                new_id,
                knowledge_id,
                new_user_id,
                datetime.now(),
                0
            )
            
            mysql_cursor.execute(insert_sql, values)
            
        self.mysql_conn.commit()
        print(f"âœ… æ”¶è—æ•°æ®è¿ç§»å®Œæˆ: {len(favorites)} æ¡è®°å½•")
    
    def run_migration(self):
        """è¿è¡Œå®Œæ•´è¿ç§»"""
        print("ðŸš€ å¼€å§‹åŽ†å²ç³»ç»Ÿæ•°æ®è¿ç§»...")
        
        try:
            # è¿žæŽ¥æ•°æ®åº“
            self.connect_databases()
            # ç¡®ä¿ç›®æ ‡åº“æ–°å¢žå­—æ®µå·²å°±ç»ª
            self.ensure_target_schema()
            
            # æŒ‰é¡ºåºè¿ç§»æ•°æ®
            self.migrate_users()
            self.migrate_categories()
            self.migrate_content()
            self.migrate_uploads()
            self.migrate_feedbacks()
            self.migrate_favorites()
            
            print("\nâœ… æ•°æ®è¿ç§»å®Œæˆï¼")
            print(f"ðŸ“Š IDæ˜ å°„å…³ç³»å·²ä¿å­˜ï¼Œå…± {len(self.id_mapping)} ä¸ªæ˜ å°„")
            
        except Exception as e:
            print(f"âŒ è¿ç§»è¿‡ç¨‹ä¸­å‡ºçŽ°é”™è¯¯: {e}")
            if self.mysql_conn:
                self.mysql_conn.rollback()
        finally:
            # å…³é—­è¿žæŽ¥
            if self.sqlite_conn:
                self.sqlite_conn.close()
            if self.mysql_conn:
                self.mysql_conn.close()

def main():
    # é…ç½®
    sqlite_db_path = input("è¯·è¾“å…¥ SQLite æ•°æ®åº“æ–‡ä»¶è·¯å¾„: ").strip()
    if not os.path.exists(sqlite_db_path):
        print("âŒ SQLite æ•°æ®åº“æ–‡ä»¶ä¸å­˜åœ¨ï¼")
        return
    
    mysql_config = {
        'host': 'localhost',
        'user': 'root',
        'password': 'xmc131455',
        'database': 'knowledge_base'
    }
    
    # è¿è¡Œè¿ç§»
    migration = LegacyDataMigration(sqlite_db_path, mysql_config)
    migration.run_migration()

if __name__ == "__main__":
    main()
